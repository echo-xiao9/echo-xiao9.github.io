---
layout: post
title: graph lab
description: "dijstra ç®—æ³•åŠå †ä¼˜åŒ–"
modified: 2021-05-21
tags: [sample post]
image:
  path: /images/abstract-8.jpg
  feature: abstract-8.jpg
  credit: dargadgetz
  creditlink: http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/
---

# æœ€çŸ­è·¯å¾„ï¼ˆShortest Pathï¼‰

æœ€çŸ­è·¯å¾„æ˜¯å›¾è®ºç ”ç©¶ä¸­çš„ä¸€ä¸ªç»å…¸é—®é¢˜ï¼Œæ—¨åœ¨å¯»æ‰¾å›¾ï¼ˆç”±èŠ‚ç‚¹å’Œè·¯å¾„ç»„æˆçš„ï¼‰ä¸­ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚ä¸¤ç§æ¯”è¾ƒå…¸å‹çš„æ–¹å¼æ˜¯æ±‚å•æºæœ€çŸ­è·¯å¾„ï¼ˆSingle Source Shortest Pathï¼‰å’Œå…¨æºæœ€çŸ­è·¯å¾„ï¼ˆAll Pairs Shortest Pathï¼‰ã€‚å•æºæœ€çŸ­è·¯å¾„æ˜¯ç»™å®šä¸€ä¸ªç‚¹ï¼Œæ±‚è¯¥ç‚¹åˆ°å‰©ä½™å…¶ä»–ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œå¯ä»¥ç”¨Dijkstraæˆ–è€…Bellman-fordç®—æ³•è§£å†³ï¼›å…¨æºæœ€çŸ­è·¯å¾„è¦æ±‚æ±‚å‡ºå›¾ä¸­æ‰€æœ‰ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼Œå¯ä»¥å°†æ¯ä¸ªç‚¹çœ‹ä½œåšæºç‚¹æ‰§è¡Œè‹¥å¹²æ¬¡è®¡ç®—å•æºæœ€çŸ­è·¯å¾„ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨Floyd-Warshallç®—æ³•ç›´æ¥è®¡ç®—å…¨æºæœ€çŸ­è·¯å¾„ã€‚ åˆ©ç”¨å›¾çš„æœ€çŸ­è·¯å¾„å¯ä»¥è¿›ä¸€æ­¥åˆ†æå‡ºå›¾çš„ä¸€äº›å±æ€§ï¼Œä»è€Œäº†è§£å›¾çš„ä¸€äº›ç‰¹ç‚¹ã€‚æœ¬æ¬¡Labä¸­æˆ‘ä»¬å°†åˆ©ç”¨æœ€çŸ­è·¯å¾„æ¥è®¡ç®—å›¾ä¸­ç‚¹çš„ä¸­å¿ƒæ€§ï¼ˆCentralityï¼‰ã€‚ä¸­å¿ƒæ€§æ˜¯ç¤¾äº¤ç½‘ç»œå›¾åˆ†æä¸­å¸¸ç”¨çš„å±æ€§ï¼Œåœ¨ç°å®ç”Ÿæ´»ä¸­å…·æœ‰é‡è¦æ„ä¹‰ã€‚

## åº¦ä¸­å¿ƒæ€§ï¼ˆDegree Centralityï¼‰

$ğ·ğ¶(ğ‘£)= ğ‘‘ğ‘’ğ‘”ğ‘Ÿğ‘’ğ‘’(ğ‘£)$

åº¦ä¸­å¿ƒæ€§æ˜¯åœ¨ç½‘ç»œåˆ†æä¸­åˆ»ç”»èŠ‚ç‚¹ä¸­å¿ƒæ€§æœ€ç®€å•ç›´æ¥çš„æ–¹æ³•ï¼Œä¸€ä¸ªèŠ‚ç‚¹çš„åº¦è¶Šå¤§å°±æ„å‘³ç€è¿™ä¸ªèŠ‚ç‚¹çš„åº¦ä¸­å¿ƒæ€§è¶Šé«˜ï¼Œè¯¥èŠ‚ç‚¹åœ¨ç½‘ç»œä¸­çŸ¥ååº¦è¶Šé«˜ï¼Œå› ä¸ºå’Œä»–æœ‰ç›´æ¥å…³ç³»çš„äººæœ€å¤šã€‚

`å®ç°`ï¼šç›´æ¥æ±‚é‚»æ¥è¡¨çš„sizeå°±å¯ä»¥

## äº²è¿‘ä¸­å¿ƒæ€§ï¼ˆCloseness Centralityï¼‰
<figure>
  <img src="/images/coding/2021-05-21_7.49.31.png" alt="ORB-SLAMæµç¨‹å›¾">
</figure>

<!-- ![Data%20Structure%20%E2%80%94%E2%80%94%20graph%20lab%2041f1903983554c0d84b16a7db54da67f/2021-05-21_7.49.31.png](Data%20Structure%20%E2%80%94%E2%80%94%20graph%20lab%2041f1903983554c0d84b16a7db54da67f/2021-05-21_7.49.31.png) -->

å›¾ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„äº²è¿‘ä¸­å¿ƒåº¦çš„è®¡ç®—æ–¹æ³•å¦‚ä¸Šå¼æ‰€ç¤ºï¼Œå…¶ä¸­Næ˜¯è¯¥èŠ‚ç‚¹æ‰€åœ¨çš„è¿é€šåˆ†é‡ä¸­ç‚¹çš„ä¸ªæ•°ï¼ˆLabå‡è®¾ç»™å®šçš„ç¤¾äº¤ç½‘ç»œå›¾éƒ½æ˜¯ä¸€ä¸ªè¿é€šå›¾ï¼Œå› æ­¤ç›¸å½“äºæ˜¯å›¾ä¸­æ‰€æœ‰çš„èŠ‚ç‚¹ï¼‰
$ğ‘‘ğ‘–ğ‘ ğ‘¡(ğ‘£,ğ‘£â€²)$æ˜¯èŠ‚ç‚¹Vå’ŒVâ€™ä¹‹é—´çš„æœ€çŸ­è·ç¦»ã€‚å‰æ–‡ä¸­çš„åº¦ä¸­å¿ƒæ€§åªåˆ©ç”¨äº†ç½‘ç»œçš„å±€éƒ¨æ€§è´¨ï¼Œè€Œäº²è¿‘ä¸­å¿ƒæ€§åˆ™èƒ½è¡¨ç¤ºä¸€ä¸ªç‚¹åœ¨æ•´ä¸ªç½‘ç»œä¸­çš„ä½ç½®ã€‚ä¸€ä¸ªèŠ‚ç‚¹çš„äº²è¿‘ä¸­å¿ƒåº¦è¶Šå¤§ï¼Œåˆ™å…¶è¶Šæ¥è¿‘æ•´ä¸ªå›¾çš„å‡ ä½•ä¸­å¿ƒã€‚è¿™ä¸€ç±»äººæœªå¿…å…·æœ‰å¾ˆé«˜çš„çŸ¥ååº¦ï¼Œä½†æ˜¯åŒæ ·åœ¨ç¤¾äº¤ç½‘ç»œä¸­æ‰®æ¼”ç€å¾ˆé‡è¦çš„è§’è‰²ï¼Œé€šè¿‡ä»–ä»¬ï¼Œä¿¡æ¯å¯ä»¥æ›´å¿«åœ°ä¼ é€’åˆ°ç½‘ç»œä¸­çš„æ¯ä¸ªäºº

`å®ç°ï¼š` å†™äº†ä¸€ä¸ªå‡½æ•°  `double Graph::shortestPath(int src,vector<int> &dist)`ï¼Œè¾“å…¥ä¸€ä¸ªsrc,å¯ä»¥æ±‚å‡ºåˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œæ‰€ä»¥ï¼Œå¯¹äºæ¯ä¸ªç‚¹ï¼Œæ±‚å‡ºè¿™äº›é•¿åº¦ä¹‹å’Œï¼Œæ‰¾åˆ°å’Œæœ€å°çš„é‚£ä¸ªå°±å¯ä»¥

## ä¸­ä»‹ä¸­å¿ƒæ€§ï¼ˆBetweenness Centralityï¼‰


<figure>
  <img src="/images/coding/2021-05-21_7.53.57.png" alt="ORB-SLAMæµç¨‹å›¾">
</figure>

<!-- ![Data%20Structure%20%E2%80%94%E2%80%94%20graph%20lab%2041f1903983554c0d84b16a7db54da67f/2021-05-21_7.53.57.png](Data%20Structure%20%E2%80%94%E2%80%94%20graph%20lab%2041f1903983554c0d84b16a7db54da67f/2021-05-21_7.53.57.png) -->

å¦‚ä¸Šå¼æ‰€ç¤ºï¼Œä¸€ä¸ªç‚¹çš„ä¸­ä»‹ä¸­å¿ƒåº¦æ˜¯å®ƒå‡ºç°åœ¨å…¶ä»–ç‚¹å¯¹ä¹‹é—´æœ€çŸ­è·¯å¾„çš„æ¬¡æ•°ï¼ˆä¸¤ä¸ªç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„å¯èƒ½æœ‰å¤šæ¡ï¼Œåªè¦ç‚¹våœ¨ç‚¹viå’Œvjçš„å¤šæ¡æœ€çŸ­è·¯å¾„ä¸­å‡ºç°ä¸€æ¬¡ï¼Œå³å¯è®¡ç®—ä¸€æ¬¡ï¼Œå‡ºç°å¤šæ¬¡ä¹Ÿåªè®¡ç®—ä¸€æ¬¡ã€‚å› ä¸ºæ˜¯æ— å‘å›¾ï¼Œä»»æ„ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„æ˜¯å¯¹ç§°çš„ï¼Œæ‰€ä»¥åœ¨æ±‚å’Œä¹‹åé™¤ä»¥2ï¼‰ã€‚ä¸äº²è¿‘ä¸­å¿ƒæ€§ç›¸åŒï¼Œä¸­ä»‹ä¸­å¿ƒæ€§åŒæ ·æ˜¯å¯¹ç½‘ç»œå…¨å±€å±æ€§çš„ä¸€ä¸ªåˆ»ç”»ã€‚ä¸€ä¸ªç‚¹çš„ä¸­ä»‹ä¸­å¿ƒåº¦é«˜åˆ™åœ¨ç½‘ç»œä¸­æœ‰å¾ˆå¤šäººä¹‹é—´çš„é—´æ¥å…³ç³»ä¼šä¾èµ–äºå®ƒï¼Œè¿™æ„å‘³ç€è¯¥ç‚¹å¯¹å…¶ä»–æˆå‘˜æœ‰è¾ƒå¼ºçš„æ§åˆ¶å’Œåˆ¶çº¦å…³ç³»ã€‚

`å®ç°` : åœ¨`shortestPath`  å‡½æ•°é‡Œï¼Œå…¶å®æ˜¯æ‰¾åˆ°äº†ä¸€ä¸ªç‚¹åˆ°å…¶ä»–ç‚¹çš„æœ€çŸ­è·¯ï¼Œè¿™ä¸ªå›¾çš„æ¯ä¸ªçº¿æ¡çš„æ–¹å‘éƒ½å®šä¸‹æ¥äº†ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªç‚¹çš„fatheréƒ½å”¯ä¸€ç¡®å®šäº†ï¼Œæ‰€ä»¥é’ˆå¯¹è¿™ä¸ªæ–°çš„ç”Ÿæˆçš„æœ‰å‘å›¾ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªfatheræ•°ç»„å»è®°å½•å‰ç»§father(å„¿å­å¯èƒ½æœ‰å¤šä¸ª)ã€‚ç„¶åéå†æ¯ä¸ªç‚¹ï¼Œéƒ½å¯ä»¥æ‰¾å›åˆ°srcçš„ä¸€æ¡è·¯å¾„ï¼Œè·¯å¾„ä¸Šçš„æ¯ä¸ªç‚¹çš„betweenness++

# å®éªŒè¦æ±‚

è¾“å…¥ å‚æ•°ä¸€æ˜¯æ–‡æœ¬æ–‡ä»¶çš„è·¯å¾„ï¼Œé€šè¿‡mainå‡½æ•°çš„argv[1]æ¥æ”¶ã€‚è¯¥æ–‡ä»¶åŒ…å«å¤šè¡Œï¼Œç¬¬ä¸€è¡Œä¸ºæ€»èŠ‚ç‚¹ä¸ªæ•°ã€‚å…¶åçš„dæ¯ä¸€è¡Œç”±ä¸‰ä¸ªæ— ç¬¦å·32ä½æ•´å‹v1ï¼Œv2å’Œweightç»„æˆï¼Œç”±é€—å·éš”å¼€ï¼Œv1å’Œv2ä»£è¡¨ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„ç¼–å·ï¼ˆèŠ‚ç‚¹ç¼–å·æ˜¯è¿ç»­çš„ï¼Œä»0å¼€å§‹ï¼‰ï¼Œweightæ˜¯è¿™ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´è¾¹çš„æƒé‡ã€‚ç¤¾äº¤ç½‘ç»œä¸€èˆ¬ä¸ä¼šååˆ†ç¨ å¯†ï¼Œæ‰€ä»¥æœ¬æ¬¡Labçš„è¾“å…¥æ»¡è¶³|E| << |V|Â²ï¼Œè¯·é€‰æ‹©åˆé€‚çš„ç®—æ³•ã€‚ è¾“å‡º ä¾æ¬¡è¾“å‡ºä¸‰ä¸ªåˆ†åˆ«å…·æœ‰æœ€é«˜åº¦ã€æ¥è¿‘ä¸­å¿ƒåº¦å’Œä¸­ä»‹ä¸­å¿ƒåº¦çš„èŠ‚ç‚¹çš„ç¼–å·åŠå¯¹åº”å€¼ï¼Œå€¼ç›¸åŒé€‰æ‹©ç¼–å·å°çš„èŠ‚ç‚¹ã€‚

<figure>
  <img src="/images/coding/2021-05-21_8.03.12.png" alt="ORB-SLAMæµç¨‹å›¾">
</figure>
<!-- 
![Data%20Structure%20%E2%80%94%E2%80%94%20graph%20lab%2041f1903983554c0d84b16a7db54da67f/2021-05-21_8.03.12.png](Data%20Structure%20%E2%80%94%E2%80%94%20graph%20lab%2041f1903983554c0d84b16a7db54da67f/2021-05-21_8.03.12.png) -->

å¦‚å›¾1æ‰€ç¤ºï¼Œåˆ™è¾“å…¥çš„æ–‡ä»¶å†…å®¹å¦‚ä¸‹ï¼š 

5 

0,3,2 

3,4,2 

1,4,1 

1,2,1 

2,3,5 

éœ€è¦çš„è¾“å‡ºå¦‚ä¸‹ï¼ŒèŠ‚ç‚¹3çš„åº¦æœ€é«˜ä¸º3ï¼ŒèŠ‚ç‚¹4çš„æ¥è¿‘ä¸­å¿ƒåº¦æœ€é«˜ä¸º0.444444ï¼ˆä»»æ„ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·ç¦»å€¼å°äºæ— ç¬¦å·32ä½æ•´å‹çš„ä¸Šé™ï¼Œæ¥è¿‘ä¸­å¿ƒåº¦è®¡ç®—å’Œè¾“å‡ºéƒ½ä½¿ç”¨doubleç±»å‹ï¼Œä¿ç•™6ä½å°æ•°ï¼‰ï¼ŒèŠ‚ç‚¹4çš„ä¸­ä»‹ä¸­å¿ƒåº¦æœ€é«˜ä¸º4ï¼ˆä¸­ä»‹ä¸­å¿ƒåº¦çš„å€¼ä¸ä¼šè¶…è¿‡æ— ç¬¦å·32ä½æ•´å‹ï¼‰ã€‚ 

3 3 

4 0.444444 

4 4
<figure>
  <img src="/images/coding/2021-05-21_8.03.02.png" alt="ORB-SLAMæµç¨‹å›¾">
</figure>

<!-- ![Data%20Structure%20%E2%80%94%E2%80%94%20graph%20lab%2041f1903983554c0d84b16a7db54da67f/2021-05-21_8.03.02.png](Data%20Structure%20%E2%80%94%E2%80%94%20graph%20lab%2041f1903983554c0d84b16a7db54da67f/2021-05-21_8.03.02.png) -->

# ä»£ç 

```cpp
//
//  main.cpp
//  graphlab
//
//  Created by åº·è‰ºæ½‡ on 2021/5/20.
//

#include <iostream>
#include <list>
#include <vector>
#include <queue>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Program to find Dijkstra's shortest path using
// priority_queue in STL
using namespace std;
# define INF 0x3f3f3f3f
//const int maxVertices=200000;
// iPair ==> Integer Pair
typedef pair<int, int> iPair;

// This class represents a directed graph using
// adjacency list representation
class Graph
{
    int V; // No. of vertices
    // In a weighted graph, we need to store vertex
    // and weight pair for every edge
    list< pair<int, int> > *adj;
    
    
    int* bewteenVec; // The number of the ith node in the shortest path of the other nodes
public:
    Graph(int V); // Constructor
    
    // function to add an edge to graph
    void addEdge(int u, int v, int w);
    
    // prints shortest path from s
    double shortestPath(int src,vector<int> &dist);
    void getMaxDegreeCentrality(int &maxDegreeCentrality, int &maxDegreeCentralityIndex);
    void BetweennessCentrality(
                               int &maxBetweennessCentrality,
                               int &maxBetweennessCentralityIndex);
    void getClosenessCentrality(double &maxClosenessCentrality,
                                int &maxClosenessCentralityIndex);
};

// Allocates memory for adjacency list
Graph::Graph(int V)
{
    this->V = V;
    adj = new list<iPair> [V];
    bewteenVec = new int[V+5];
    for(int i=0;i<V+5;i++)bewteenVec[i]=0;
    
}

void Graph::addEdge(int u, int v, int w)
{
    adj[u].push_back(make_pair(v, w));
    adj[v].push_back(make_pair(u, w));
}

// Prints shortest paths from src to all other vertices
double Graph::shortestPath(int src,vector<int> &dist)
{
    // Create a priority queue to store vertices that
    // are being preprocessed. This is weird syntax in C++.
    priority_queue< iPair, vector <iPair> , greater<iPair> > pq;
    int lastNode=0;
    int v=0;int tmp=0;
    
    int *father = new int[V+5];
    for(int i=0;i<V+5;i++)father[i]=-1;
    // Create a vector for distances and initialize all
    // distances as infinite (INF)
    //    vector<int> dist(V, INF);
//    cout<<"src:"<<src<<endl;
    // Insert source itself in priority queue and initialize
    // its distance as 0.
    pq.push(make_pair(0, src));
    dist[src] = 0;
    
    /* Looping till priority queue becomes empty (or all
     distances are not finalized) */
    while (!pq.empty())
    {
        // The first vertex in pair is the minimum distance
        // vertex, extract it from priority queue.
        // vertex label is stored in second of pair (it
        // has to be done this way to keep the vertices
        // sorted distance (distance must be first item
        // in pair)
        int u = pq.top().second;
        pq.pop();
        
        // 'i' is used to get all adjacent vertices of a vertex
        list< pair<int, int> >::iterator i;
        for (i = adj[u].begin(); i != adj[u].end(); ++i)
        {
            // Get vertex label and weight of current adjacent
            // of u.
            v = (*i).first;
            int weight = (*i).second;
            
            // If there is shorted path to v through u.
            if (dist[v] > dist[u] + weight)
            {
                // Updating distance of v
                dist[v] = dist[u] + weight;
                father[v]=u;
                pq.push(make_pair(dist[v], v));
                lastNode = u;
            }
        }
        
        }
    for(int i=0;i<V;i++){
        tmp=father[i];
        while (tmp!=-1 && father[tmp]!= -1) {
            bewteenVec[tmp]++;
            tmp=father[tmp];
        }
    }
    
    // Print shortest distances stored in dist[]
    int sumDist=0;
    for (int i = 0; i < V; ++i){
        sumDist+=dist[i];
    }
    //        printf("%d \t\t %d\n", i, dist[i]);
    return sumDist;
}

void Graph::getMaxDegreeCentrality(int &maxDegreeCentrality, int &maxDegreeCentralityIndex){
    int maxDegree=0;
    int maxDegreeIndex=0;
    for(int i=0;i<V;i++){
        int size = adj[i].size();
        if(size>maxDegree){
            maxDegree = size;
            maxDegreeIndex= i;
        }
    }
    maxDegreeCentrality = maxDegree;
    maxDegreeCentralityIndex = maxDegreeIndex;
}

void Graph::BetweennessCentrality(
                                  int &maxBetweennessCentrality,
                                  int &maxBetweennessCentralityIndex){
    
    for(int i=0;i<V;i++){
        if(bewteenVec[i]>maxBetweennessCentrality){
            maxBetweennessCentrality=bewteenVec[i];
            maxBetweennessCentralityIndex = i;
        }
    }
    maxBetweennessCentrality/=2;
    
}

void Graph::getClosenessCentrality(double &maxClosenessCentrality,
                                   int &maxClosenessCentralityIndex){
    vector<int>sumDist;
    int minDistIndex=0;
    int minDist=INF;
    for(int i=0;i<V;i++){
        vector<int> dist(V, INF);
        sumDist.push_back(shortestPath(i,dist));
    }
    for(int i=0;i<sumDist.size();i++){
        if(minDist> sumDist[i]){
            minDist=sumDist[i];
            minDistIndex = i;
        }
    }
    maxClosenessCentralityIndex = minDistIndex;
    maxClosenessCentrality = float(float(V-1)/float(minDist));
}

// Driver program to test methods of graph class
int main(int argc, char* argv[])
{
    ifstream infile;
    int n=0;
    infile.open(argv[1]);
    int maxDegreeCentrality=0, maxDegreeCentralityIndex=0;
    double maxClosenessCentrality=INF;
    int maxClosenessCentralityIndex=0;
    int maxBetweennessCentralityIndex=0,maxBetweennessCentrality=0;
    /* èŠ‚ç‚¹æ€»æ•° */
    infile >> n;

    Graph g(n);
    char* line = new char[n];
    int64_t v1, v2, weight;
    while (infile >> line) {
        
        char *p = strtok(line, ",");
        v1 = atoi(p);
        p = strtok(NULL, ",");
        v2 = atoi(p);
        p = strtok(NULL, ",");
        weight = atoi(p);
        g.addEdge(v1, v2, weight);
    }
    g.getMaxDegreeCentrality(maxDegreeCentrality, maxDegreeCentralityIndex);
    cout<<maxDegreeCentralityIndex<< ' '<<maxDegreeCentrality<<endl;
    g.getClosenessCentrality(maxClosenessCentrality, maxClosenessCentralityIndex);
    cout<<maxClosenessCentralityIndex<< ' '<<maxClosenessCentrality<<endl;
    g.BetweennessCentrality(maxBetweennessCentrality, maxBetweennessCentralityIndex);
    cout<<maxBetweennessCentralityIndex<<' '<<maxBetweennessCentrality<<endl;
    return 0;
}
```